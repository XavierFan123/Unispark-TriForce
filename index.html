function renderProfessionalChart(dataWithSignals, config) {
      // Destroy previous chart instance
      if (globalState.chartInstance) {
        globalState.chartInstance.destroy();
        globalState.chartInstance = null;
      }

      const ctx = document.getElementById('chart');
      if (!ctx) return;
      
      const chartData = dataWithSignals.slice(-CONFIG.CHART_DISPLAY_POINTS);

      // Create professional datasets
      const datasets = [
        {
          label: `${globalState.currentAsset} ä»·æ ¼`,
          data: chartData.map(r => r.price),
          borderColor: config.color,
          backgroundColor: config.color + '15',
          borderWidth: 3,
          tension: 0.4,
          fill: true,
          pointRadius: 0,
          pointHoverRadius: 6,
          pointHitRadius: 15,
          pointHoverBackgroundColor: config.color,
          pointHoverBorderColor: '#fff',
          pointHoverBorderWidth: 2
        },
        {
          label: '20æ—¥å‡çº¿',
          data: chartData.map(r => r.MA20),
          borderColor: '#E5E7EB',
          backgroundColor: 'transparent',
          borderWidth: 2,
          borderDash: [8, 4],
          tension: 0.4,
          fill: false,
          pointRadius: 0,
          pointHoverRadius: 4
        },
        {
          label: '50æ—¥å‡çº¿',
          data: chartData.map(r => r.MA50),
          borderColor: '#9CA3AF',
          backgroundColor: 'transparent',
          borderWidth: 1.5,
          borderDash: [12, 6],
          tension: 0.4,
          fill: false,
          pointRadius: 0,
          pointHoverRadius: 4
        },
        {
          label: 'ä¹°å…¥ä¿¡å·',
          data: chartData.map(r => r.Signal === 'ä¹°å…¥' ? r.price : null),
          pointStyle: 'triangle',
          rotation: 0,
          backgroundColor: '#10B981',
          borderColor: '#ffffff',
          borderWidth: 2,
          pointRadius: 10,
          pointHoverRadius: 12,
          showLine: false,
          pointShadowBlur: 10,
          pointShadowColor: '#10B981'
        },
        {
          label: 'å–å‡ºä¿¡å·',
          data: chartData.map(r => r.Signal === 'å–å‡º' ? r.price : null),
          pointStyle: 'triangle',
          rotation: 180,
          backgroundColor: '#EF4444',
          borderColor: '#ffffff',
          borderWidth: 2,
          pointRadius: 10,
          pointHoverRadius: 12,
          showLine: false,
          pointShadowBlur: 10,
          pointShadowColor: '#EF4444'
        }
      ];

      // Add QQQ line for TQQQ
      if (globalState.currentAsset === 'TQQQ') {
        datasets.splice(1, 0, {
          label: 'QQQ ä»·æ ¼ (åŸºå‡†)',
          data: chartData.map(r => r.secondaryPrice),
          borderColor: '#8B5CF6',
          backgroundColor: 'rgba(139, 92, 246, 0.1)',
          borderWidth: 2,
          tension: 0.4,
          fill: false,
          pointRadius: 0,
          pointHoverRadius: 4,
          yAxisID: 'y1'
        });
      }

      const chartOptions = {
        responsive: true,
        maintainAspectRatio: false,
        interaction: {
          mode: 'index',
          intersect: false
        },
        plugins: {
          legend: {
            position: 'top',
            labels: {
              color: '#E5E7EB',
              font: { size: 13, weight: '600' },
              usePointStyle: true,
              padding: 25,
              boxWidth: 12,
              boxHeight: 12
            }
          },
          tooltip: {
            backgroundColor: 'rgba(0, 0, 0, 0.9)',
            titleColor: config.color,
            bodyColor: '#E5E7EB',
            borderColor: config.color + '80',
            borderWidth: 1,
            cornerRadius: 12,
            padding: 15,
            displayColors: true,
            callbacks: {
              title: (context) => {
                const date = chartData[context[0].dataIndex]?.date;
                return date ? formatDate(date) : '';
              },
              label: (context) => {
                const value = context.parsed.y;
                return `${context.dataset.label}: ${formatCurrency(value)}`;
              },
              afterBody: (context) => {
                const dataPoint = chartData[context[0].dataIndex];
                if (dataPoint?.Signal) {
                  return [`ä¿¡å·: ${dataPoint.Signal}`, `å¼ºåº¦: ${dataPoint.signalStrength || 0}%`];
                }
                return [];
              }
            }
          }
        },
        scales: {
          x: {
            grid: {
              color: config.color + '10',
              drawBorder: false
            },
            ticks: {
              color: '#9CA3AF',
              font: { size: 11 },
              maxRotation: 0,
              minRotation: 0,
              maxTicksLimit: 8
            }
          },
          y: {
            position: 'right',
            grid: {
              color: config.color + '15',
              drawBorder: false
            },
            ticks: {
              callback: (value) => formatCurrency(value),
              color: '#9CA3AF',
              font: { size: 11 },
              padding: 10
            }
          }
        },
        elements: {
          point: {
            hoverBackgroundColor: config.color
          }
        }
      };

      // Add secondary y-axis for TQQQ
      if (globalState.currentAsset === 'TQQQ') {
        chartOptions.scales.y1 = {
          type: 'linear',
          display: false,
          position: 'left'
        };
      }

      globalState.chartInstance = new Chart(ctx.getContext('2d'), {
        type: 'line',
        data: {
          labels: chartData.map(r => formatDate(r.date).substring(5)),
          datasets: datasets
        },
        options: chartOptions
      });
    }

    // ===========================
    // SYSTEM MANAGEMENT FUNCTIONS
    // ===========================
    
    function startAutoRefresh() {
      if (globalState.refreshTimer) {
        clearInterval(globalState.refreshTimer);
      }
      
      globalState.refreshTimer = setInterval(async () => {
        if (!document.hidden && !globalState.isLoading) {
          console.log('ğŸ”„ è‡ªåŠ¨åˆ·æ–°æ•°æ®...');
          try {
            await renderDashboard();
            console.log('âœ… è‡ªåŠ¨åˆ·æ–°å®Œæˆ');
          } catch (error) {
            console.error('âŒ è‡ªåŠ¨åˆ·æ–°å¤±è´¥:', error);
          }
        }
      }, CONFIG.AUTO_REFRESH_INTERVAL);
    }

    function startHealthCheck() {
      if (globalState.healthCheckTimer) {
        clearInterval(globalState.healthCheckTimer);
      }
      
      globalState.healthCheckTimer = setInterval(async () => {
        if (!document.hidden) {
          await performSystemHealthCheck();
        }
      }, CONFIG.HEALTH_CHECK_INTERVAL);
    }

    async function performSystemHealthCheck() {
      console.log('ğŸ¥ æ‰§è¡Œç³»ç»Ÿå¥åº·æ£€æŸ¥...');
      
      try {
        // Test CoinGecko API (æ›´é‡è¦çš„åŠ å¯†è´§å¸æ•°æ®æº)
        const coinGeckoTestUrl = `${CONFIG.COINGECKO_BASE_URL}/ping`;
        await fetchWithRetry(coinGeckoTestUrl, {}, 1);
        
        // Test FMP API (è‚¡ç¥¨æ•°æ®æº)
        const testUrl = `${CONFIG.FMP_BASE_URL}/quote/AAPL?apikey=${CONFIG.FMP_API_KEY}`;
        await fetchWithRetry(testUrl, {}, 1);
        
        updateApiStatus('online', 'ç³»ç»Ÿè¿è¡Œæ­£å¸¸');
        console.log('âœ… å¥åº·æ£€æŸ¥é€šè¿‡');
        return true;
        
      } catch (error) {
        console.warn('âš ï¸ å¥åº·æ£€æŸ¥å¤±è´¥:', error.message);
        updateApiStatus('offline', 'APIè¿æ¥å¼‚å¸¸');
        return false;
      }
    }

    // ===========================
    // EVENT HANDLERS & INITIALIZATION
    // ===========================
    
    // Make functions globally available
    window.switchAsset = switchAsset;
    window.renderDashboard = renderDashboard;

    // Initialize the professional trading system
    document.addEventListener('DOMContentLoaded', async function() {
      console.log('ğŸš€ åˆå§‹åŒ–Unisparkä¸“ä¸šé‡åŒ–äº¤æ˜“ç³»ç»Ÿ v2.1...');
      
      try {
        updateApiStatus('warning', 'ç³»ç»Ÿåˆå§‹åŒ–ä¸­...');
        
        // Initialize from URL parameters
        initializeFromUrl();
        
        // Perform initial system health check
        await performSystemHealthCheck();
        
        // Render initial dashboard
        await renderDashboard();
        
        // Start system management
        startAutoRefresh();
        startHealthCheck();
        
        console.log('âœ… ç³»ç»Ÿåˆå§‹åŒ–å®Œæˆ');
        
      } catch (error) {
        console.error('âŒ ç³»ç»Ÿåˆå§‹åŒ–å¤±è´¥:', error);
        updateApiStatus('offline', 'åˆå§‹åŒ–å¤±è´¥');
      }
      
      // Handle browser navigation
      window.addEventListener('popstate', function(event) {
        initializeFromUrl();
        renderDashboard();
      });

      // Professional keyboard shortcuts
      document.addEventListener('keydown', function(event) {
        if (event.ctrlKey || event.metaKey) {
          switch(event.key) {
            case '1':
              event.preventDefault();
              switchAsset('BTC');
              break;
            case '2':
              event.preventDefault();
              switchAsset('ETH');
              break;
            case '3':
              event.preventDefault();
              switchAsset('TQQQ');
              break;
            case 'r':
              event.preventDefault();
              renderDashboard();
              break;
            case 'h':
              event.preventDefault();
              performSystemHealthCheck();
              break;
          }
        }
      });

      // Handle page visibility changes
      document.addEventListener('visibilitychange', function() {
        if (document.hidden) {
          console.log('â¸ï¸ é¡µé¢éšè—ï¼Œæš‚åœæ›´æ–°');
        } else {
          console.log('â–¶ï¸ é¡µé¢å¯è§ï¼Œæ¢å¤æ›´æ–°');
          renderDashboard();
        }
      });

      // Advanced error handling
      window.addEventListener('unhandledrejection', function(event) {
        console.error('âŒ æœªå¤„ç†çš„Promiseé”™è¯¯:', event.reason);
        globalState.errorCount++;
        updateApiStatus('offline', 'ç³»ç»Ÿé”™è¯¯');
      });

      window.addEventListener('error', function(event) {
        console.error('âŒ å…¨å±€é”™è¯¯:', event.error);
        globalState.errorCount++;
      });

      // Performance monitoring
      if ('performance' in window) {
        window.addEventListener('load', function() {
          setTimeout(() => {
            const perfData = performance.getEntriesByType('navigation')[0];
            console.log(`âš¡ é¡µé¢åŠ è½½æ€§èƒ½: ${Math.round(perfData.loadEventEnd - perfData.fetchStart)}ms`);
          }, 0);
        });
      }

    });

    // Cleanup on page unload
    window.addEventListener('beforeunload', function() {
      if (globalState.refreshTimer) clearInterval(globalState.refreshTimer);
      if (globalState.healthCheckTimer) clearInterval(globalState.healthCheckTimer);
      if (globalState.chartInstance) globalState.chartInstance.destroy();
    });

  </script>

</body>
</html>    // ===========================
    // UI RENDERING FUNCTIONS
    // ===========================
    
    function renderAssetTabs() {
      return `
        <div class="flex justify-center mb-8">
          <div class="flex bg-black bg-opacity-30 rounded-3xl p-3 space-x-3 backdrop-filter backdrop-blur-lg border border-gray-800">
            ${Object.keys(assetConfigs).map(asset => {
              const config = assetConfigs[asset];
              const isActive = asset === globalState.currentAsset;
              const gradientStyle = `background: linear-gradient(135deg, ${config.gradientColors[0]}, ${config.gradientColors[1]});`;
              
              return `
                <div class="asset-tab premium-card rounded-2xl px-6 py-4 ${isActive ? 'active' : ''}" 
                     onclick="switchAsset('${asset}')" 
                     style="border-color: ${isActive ? config.color + '80' : 'rgba(255, 255, 255, 0.1)'}">
                  <div class="flex items-center space-x-4">
                    <div class="text-3xl font-bold gradient-text-custom" style="${gradientStyle} -webkit-background-clip: text; -webkit-text-fill-color: transparent;">${config.symbol}</div>
                    <div>
                      <div class="font-bold text-gray-100 text-lg">${asset}</div>
                      <div class="text-xs text-gray-400 font-medium">${config.name}</div>
                      <div class="text-xs mt-1">
                        <span class="px-2 py-0.5 rounded-full text-xs font-bold ${config.riskLevel === 'EXTREME' ? 'bg-red-500 bg-opacity-20 text-red-300' : config.riskLevel === 'HIGH' ? 'bg-yellow-500 bg-opacity-20 text-yellow-300' : 'bg-green-500 bg-opacity-20 text-green-300'}">${config.riskLevel}</span>
                      </div>
                    </div>
                  </div>
                </div>
              `;
            }).join('')}
          </div>
        </div>
      `;
    }

    function switchAsset(asset) {
      if (globalState.currentAsset !== asset && !globalState.isLoading) {
        console.log(`ğŸ”„ åˆ‡æ¢èµ„äº§: ${globalState.currentAsset} â†’ ${asset}`);
        globalState.currentAsset = asset;
        updateUrl(asset);
        renderDashboard();
      }
    }

    async function renderDashboard() {
      if (globalState.isLoading) {
        console.log('â³ ç³»ç»Ÿæ­£åœ¨åŠ è½½ä¸­ï¼Œè·³è¿‡æ¸²æŸ“');
        return;
      }

      const root = document.getElementById('root');
      const config = assetConfigs[globalState.currentAsset];
      
      // Show enhanced loading state
      root.innerHTML = `
        ${renderAssetTabs()}
        <div class="premium-card rounded-3xl p-8 text-center">
          <div class="loading-spinner mx-auto mb-8"></div>
          <h2 class="text-3xl font-bold gradient-text-gold mb-4">åŠ è½½ ${globalState.currentAsset} ä¸“ä¸šæ•°æ®</h2>
          <p class="text-gray-400 text-lg mb-2">æ­£åœ¨è¿æ¥å…¨çƒé‡‘èæ•°æ®ç½‘ç»œ...</p>
          <p class="text-gray-500 text-sm">${config.description}</p>
          <div class="mt-6 flex justify-center items-center space-x-2">
            <div class="w-2 h-2 rounded-full animate-pulse" style="background-color: ${config.color}"></div>
            <div class="text-gray-400 text-sm">å®æ—¶æ•°æ®åŒæ­¥ä¸­</div>
          </div>
        </div>
      `;

      try {
        const rawData = await loadAssetData(globalState.currentAsset);
        
        if (rawData.length < CONFIG.MA_PERIOD) {
          root.innerHTML = `
            ${renderAssetTabs()}
            <div class="error-banner">
              <div class="text-6xl mb-6 opacity-60">âš ï¸</div>
              <h2 class="text-2xl font-bold text-red-300 mb-4">æ•°æ®ä¸è¶³</h2>
              <!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Unispark ä¸“ä¸šé‡åŒ–äº¤æ˜“ç³»ç»Ÿ</title>
  <link rel="icon" type="image/svg+xml" data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMzIiIGhlaWdodD0iMzIiIHZpZXdCb3g9IjAgMCAzMiAzMiIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPHJlY3Qgd2lkdGg9IjMyIiBoZWlnaHQ9IjMyIiByeD0iOCIgZmlsbD0iIzFFMUUxRSIvPgo8cGF0aCBkPSJNOCAxNkwxNiA4TDI0IDE2TDE2IDI0TDggMTZaIiBmaWxsPSIjRkZENzAwIi8+CjwvZz4KPC9zdmc+">
  <meta name="description" content="Unisparkä¸“ä¸šé‡åŒ–äº¤æ˜“ç³»ç»Ÿ - åŸºäº20æ—¥å‡çº¿çš„æ™ºèƒ½äº¤æ˜“ä¿¡å·åˆ†æå¹³å°">
  <meta name="keywords" content="é‡åŒ–äº¤æ˜“,æŠ€æœ¯åˆ†æ,æ¯”ç‰¹å¸,ä»¥å¤ªåŠ,TQQQ,äº¤æ˜“ä¿¡å·">
  <script src="https://cdn.tailwindcss.com"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/Chart.js/4.4.0/chart.umd.js"></script>
  <style>
    @import url('https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700;800;900&display=swap');
    
    :root {
      --primary-gold: #FFD700;
      --secondary-gold: #F0E68C;
      --dark-gold: #B8860B;
      --bg-primary: #0a0a0a;
      --bg-secondary: #1a1a1a;
      --text-primary: #E0E0E0;
      --text-secondary: #B0B0B0;
      --border-primary: rgba(212, 175, 55, 0.3);
      --shadow-gold: rgba(212, 175, 55, 0.1);
    }
    
    * {
      box-sizing: border-box;
    }
    
    body {
      font-family: 'Inter', sans-serif;
      background: var(--bg-primary);
      background-image: 
        radial-gradient(ellipse at top left, rgba(255, 215, 0, 0.05) 0%, transparent 50%),
        radial-gradient(ellipse at bottom right, rgba(38, 32, 20, 0.3) 0%, transparent 70%);
      min-height: 100vh;
      color: var(--text-primary);
      overflow-x: hidden;
      line-height: 1.6;
    }

    .premium-card {
      background: linear-gradient(135deg, rgba(10, 10, 10, 0.9) 0%, rgba(26, 26, 26, 0.8) 100%);
      backdrop-filter: blur(20px);
      border: 1px solid var(--border-primary);
      box-shadow: 
        0 8px 32px 0 var(--shadow-gold),
        inset 0 1px 0 rgba(255, 255, 255, 0.1);
      transition: all 0.5s cubic-bezier(0.25, 0.8, 0.25, 1);
      position: relative;
      overflow: hidden;
    }
    
    .premium-card::before {
      content: '';
      position: absolute;
      top: 0;
      left: -100%;
      width: 100%;
      height: 100%;
      background: linear-gradient(90deg, transparent, rgba(255, 215, 0, 0.1), transparent);
      transition: left 0.5s;
    }
    
    .premium-card:hover::before {
      left: 100%;
    }
    
    .premium-card:hover {
      transform: translateY(-8px) scale(1.01);
      border-color: rgba(255, 215, 0, 0.7);
      box-shadow: 
        0 20px 60px 0 rgba(212, 175, 55, 0.3),
        inset 0 1px 0 rgba(255, 255, 255, 0.2);
    }

    .gradient-text-gold {
      background: linear-gradient(120deg, var(--primary-gold) 20%, var(--secondary-gold) 50%, var(--dark-gold) 90%);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      background-clip: text;
      font-weight: 800;
    }

    .gradient-text-custom {
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      background-clip: text;
      font-weight: 700;
    }

    .status-indicator {
      position: relative;
      display: inline-block;
    }

    .status-indicator::before {
      content: '';
      position: absolute;
      top: -4px; left: -4px; right: -4px; bottom: -4px;
      border-radius: 50%;
      background: linear-gradient(45deg, var(--primary-gold), var(--dark-gold));
      z-index: -1;
      animation: status-glow 3s ease-in-out infinite alternate;
    }

    @keyframes status-glow {
      from { 
        box-shadow: 0 0 10px rgba(255, 215, 0, 0.6);
        transform: scale(1);
      }
      to { 
        box-shadow: 0 0 25px rgba(255, 215, 0, 0.9);
        transform: scale(1.1);
      }
    }
    
    .pulse-animation {
      animation: pulse-premium 2.5s cubic-bezier(0.4, 0, 0.6, 1) infinite;
    }
    
    @keyframes pulse-premium {
      0%, 100% { 
        transform: scale(1); 
        opacity: 1; 
      }
      50% { 
        transform: scale(1.15); 
        opacity: 0.8; 
      }
    }
    
    .loading-spinner {
      width: 60px;
      height: 60px;
      border: 4px solid rgba(255, 215, 0, 0.2);
      border-top: 4px solid var(--primary-gold);
      border-radius: 50%;
      animation: spin-premium 1.2s cubic-bezier(0.4, 0.2, 0.2, 1) infinite;
      box-shadow: 0 0 20px rgba(255, 215, 0, 0.3);
    }
    
    @keyframes spin-premium {
      from { transform: rotate(0deg); }
      to { transform: rotate(360deg); }
    }

    .asset-tab {
      transition: all 0.4s cubic-bezier(0.25, 0.8, 0.25, 1);
      cursor: pointer;
      position: relative;
      overflow: hidden;
    }

    .asset-tab::before {
      content: '';
      position: absolute;
      top: 0;
      left: -100%;
      width: 100%;
      height: 100%;
      background: linear-gradient(90deg, transparent, rgba(255, 215, 0, 0.1), transparent);
      transition: left 0.4s;
    }

    .asset-tab:hover::before {
      left: 100%;
    }

    .asset-tab.active {
      background: linear-gradient(135deg, rgba(255, 215, 0, 0.25), rgba(212, 175, 55, 0.15));
      border-color: rgba(255, 215, 0, 0.8);
      transform: translateY(-3px) scale(1.02);
      box-shadow: 0 12px 30px rgba(255, 215, 0, 0.2);
    }

    .asset-tab:not(.active):hover {
      background: rgba(255, 215, 0, 0.08);
      border-color: rgba(255, 215, 0, 0.4);
      transform: translateY(-2px);
    }

    .api-status {
      position: fixed;
      top: 24px;
      right: 24px;
      z-index: 1000;
      padding: 12px 20px;
      border-radius: 25px;
      font-size: 13px;
      font-weight: 600;
      backdrop-filter: blur(15px);
      transition: all 0.3s ease;
      box-shadow: 0 8px 25px rgba(0, 0, 0, 0.3);
    }

    .api-status.online {
      background: linear-gradient(135deg, rgba(34, 197, 94, 0.25), rgba(22, 163, 74, 0.15));
      border: 1px solid rgba(34, 197, 94, 0.6);
      color: #22c55e;
    }

    .api-status.offline {
      background: linear-gradient(135deg, rgba(239, 68, 68, 0.25), rgba(220, 38, 38, 0.15));
      border: 1px solid rgba(239, 68, 68, 0.6);
      color: #ef4444;
    }

    .api-status.warning {
      background: linear-gradient(135deg, rgba(245, 158, 11, 0.25), rgba(217, 119, 6, 0.15));
      border: 1px solid rgba(245, 158, 11, 0.6);
      color: #f59e0b;
    }

    .error-banner {
      background: linear-gradient(135deg, rgba(239, 68, 68, 0.15), rgba(220, 38, 38, 0.08));
      border: 1px solid rgba(239, 68, 68, 0.4);
      border-radius: 16px;
      padding: 24px;
      margin-bottom: 24px;
      text-align: center;
      backdrop-filter: blur(10px);
    }

    .success-banner {
      background: linear-gradient(135deg, rgba(34, 197, 94, 0.15), rgba(22, 163, 74, 0.08));
      border: 1px solid rgba(34, 197, 94, 0.4);
      border-radius: 16px;
      padding: 20px;
      margin-bottom: 20px;
      text-align: center;
      backdrop-filter: blur(10px);
    }

    .metric-card {
      background: linear-gradient(135deg, rgba(255, 255, 255, 0.02), rgba(255, 255, 255, 0.01));
      border: 1px solid rgba(255, 255, 255, 0.1);
      transition: all 0.4s ease;
    }

    .metric-card:hover {
      background: linear-gradient(135deg, rgba(255, 255, 255, 0.05), rgba(255, 255, 255, 0.02));
      border-color: rgba(255, 215, 0, 0.3);
      transform: translateY(-2px);
    }

    .chart-container {
      background: linear-gradient(135deg, rgba(0, 0, 0, 0.4), rgba(26, 26, 26, 0.2));
      border: 1px solid rgba(255, 255, 255, 0.05);
      border-radius: 16px;
      padding: 20px;
      position: relative;
      overflow: hidden;
    }

    .signal-item {
      background: linear-gradient(135deg, rgba(255, 255, 255, 0.03), rgba(255, 255, 255, 0.01));
      border: 1px solid rgba(255, 255, 255, 0.1);
      transition: all 0.3s ease;
    }

    .signal-item:hover {
      border-color: var(--primary-gold);
      background: linear-gradient(135deg, rgba(255, 215, 0, 0.08), rgba(255, 215, 0, 0.04));
      transform: translateX(4px);
    }

    .btn-premium {
      background: linear-gradient(135deg, var(--primary-gold), var(--dark-gold));
      color: #000;
      font-weight: 700;
      transition: all 0.3s ease;
      box-shadow: 0 4px 15px rgba(255, 215, 0, 0.3);
    }

    .btn-premium:hover {
      background: linear-gradient(135deg, var(--secondary-gold), var(--primary-gold));
      transform: translateY(-2px);
      box-shadow: 0 8px 25px rgba(255, 215, 0, 0.4);
    }

    .watermark {
      position: fixed;
      bottom: 20px;
      left: 20px;
      font-size: 11px;
      color: rgba(255, 255, 255, 0.3);
      z-index: 1000;
      pointer-events: none;
    }

    /* Mobile Optimization */
    @media (max-width: 768px) {
      .api-status {
        top: 16px;
        right: 16px;
        padding: 8px 16px;
        font-size: 11px;
      }
      
      .premium-card {
        margin: 8px;
      }
      
      .asset-tab {
        padding: 12px 16px !important;
      }
    }

    /* High DPI Display Optimization */
    @media (-webkit-min-device-pixel-ratio: 2), (min-resolution: 192dpi) {
      .premium-card {
        border-width: 0.5px;
      }
    }

    /* Performance Optimization */
    .chart-container canvas {
      image-rendering: -webkit-optimize-contrast;
      image-rendering: crisp-edges;
    }

    /* Custom Scrollbar */
    ::-webkit-scrollbar {
      width: 8px;
    }

    ::-webkit-scrollbar-track {
      background: rgba(255, 255, 255, 0.05);
      border-radius: 4px;
    }

    ::-webkit-scrollbar-thumb {
      background: linear-gradient(180deg, var(--primary-gold), var(--dark-gold));
      border-radius: 4px;
    }

    ::-webkit-scrollbar-thumb:hover {
      background: linear-gradient(180deg, var(--secondary-gold), var(--primary-gold));
    }
  </style>
</head>
<body>

  <div id="apiStatus" class="api-status warning">ğŸŸ¡ åˆå§‹åŒ–ç³»ç»Ÿ...</div>
  <div class="watermark">Unispark Professional Trading System v2.1</div>

  <div id="root" class="max-w-7xl mx-auto p-4 md:p-6">
    <div class="premium-card rounded-3xl p-8 text-center">
      <div class="loading-spinner mx-auto mb-8"></div>
      <h2 class="text-3xl font-bold gradient-text-gold mb-4">åˆå§‹åŒ–ä¸“ä¸šé‡åŒ–ç³»ç»Ÿ</h2>
      <p class="text-gray-400 text-lg">æ­£åœ¨è¿æ¥å…¨çƒé‡‘èæ•°æ®ç½‘ç»œ...</p>
      <div class="mt-6 flex justify-center space-x-2">
        <div class="w-2 h-2 bg-yellow-400 rounded-full animate-bounce"></div>
        <div class="w-2 h-2 bg-yellow-400 rounded-full animate-bounce" style="animation-delay: 0.1s"></div>
        <div class="w-2 h-2 bg-yellow-400 rounded-full animate-bounce" style="animation-delay: 0.2s"></div>
      </div>
    </div>
  </div>

  <script>
    // ===========================
    // GLOBAL CONFIGURATION
    // ===========================
    
    const CONFIG = {
      // API Configuration - Financial Modeling Prep
      FMP_API_KEY: "cKlA3lVOMxMjg4hJsC0cn1YAIUu1Hk8P",
      FMP_BASE_URL: "https://financialmodelingprep.com/api/v3",
      
      // Alpha Vantage API configuration
      ALPHA_VANTAGE_API_KEY: "VHP8009U5A1F7XRG",
      ALPHA_VANTAGE_BASE_URL: "https://www.alphavantage.co/query",
      
      // RapidAPI Alpha Vantage configuration (backup)
      RAPIDAPI_KEY: "3e7dac5a3amsha849adb1f85821ep1e948ajsn42a2faebbec5",
      RAPIDAPI_ALPHA_VANTAGE_HOST: "alpha-vantage.p.rapidapi.com",
      
      // CoinGecko API - ä¸»è¦åŠ å¯†è´§å¸æ•°æ®æº
      COINGECKO_BASE_URL: "https://api.coingecko.com/api/v3",
      
      // Refresh intervals (in milliseconds)
      AUTO_REFRESH_INTERVAL: 5 * 60 * 1000, // 5 minutes
      HEALTH_CHECK_INTERVAL: 2 * 60 * 1000, // 2 minutes
      
      // Chart configuration
      CHART_DATA_POINTS: 90, // 90 days of data
      CHART_DISPLAY_POINTS: 60, // Show last 60 days on chart
      
      // Trading parameters
      MA_PERIOD: 20,
      BUY_THRESHOLD: 1.01, // 1% above MA
      SELL_THRESHOLD: 0.99, // 1% below MA
      
      // Rate limiting
      MAX_RETRIES: 3,
      RETRY_DELAY_MS: 1000,
      
      // UI Configuration
      ANIMATION_DURATION: 400,
      CHART_HEIGHT: 120
    };

    // ===========================
    // GLOBAL STATE MANAGEMENT
    // ===========================
    
    let globalState = {
      currentAsset: 'BTC',
      chartInstance: null,
      apiHealthy: false,
      lastUpdateTime: null,
      dataCache: new Map(),
      refreshTimer: null,
      healthCheckTimer: null,
      isLoading: false,
      errorCount: 0
    };

    // ===========================
    // ASSET CONFIGURATIONS
    // ===========================
    
    const assetConfigs = {
      BTC: { 
        name: 'Bitcoin', 
        symbol: 'â‚¿', 
        apiSymbol: 'BTCUSD',
        coinGeckoId: 'bitcoin',
        color: '#FF9500', 
        gradientColors: ['#FF9500', '#FFB84D', '#CC7700'], 
        showSecondary: false, 
        description: 'å…¨çƒæ•°å­—é»„é‡‘ - å¸‚å€¼ç¬¬ä¸€åŠ å¯†è´§å¸',
        riskLevel: 'HIGH',
        category: 'CRYPTO'
      },
      ETH: { 
        name: 'Ethereum', 
        symbol: 'Î', 
        apiSymbol: 'ETHUSD',
        coinGeckoId: 'ethereum',
        color: '#627EEA', 
        gradientColors: ['#627EEA', '#8FA8F5', '#4A69D6'], 
        showSecondary: false, 
        description: 'æ™ºèƒ½åˆçº¦å¹³å°é¢†å¯¼è€… - Web3åŸºç¡€è®¾æ–½',
        riskLevel: 'HIGH',
        category: 'CRYPTO'
      },
      TQQQ: { 
        name: 'ProShares UltraPro QQQ', 
        symbol: 'TQQQ', 
        apiSymbol: 'TQQQ',
        indicatorSymbol: 'QQQ', 
        color: '#00D4AA', 
        gradientColors: ['#00D4AA', '#4DEBA8', '#00B894'], 
        showSecondary: true, 
        secondaryName: 'NASDAQ-100 (QQQ)', 
        description: 'çº³æ–¯è¾¾å…‹ç§‘æŠ€è‚¡3å€æ æ†ETF - é«˜æ”¶ç›Šé«˜é£é™©',
        riskLevel: 'EXTREME',
        category: 'ETF'
      }
    };

    // ===========================
    // UTILITY FUNCTIONS
    // ===========================
    
    function updateApiStatus(status, message = '') {
      const statusElement = document.getElementById('apiStatus');
      if (!statusElement) return;

      globalState.apiHealthy = status === 'online';
      
      const statusConfig = {
        online: { 
          class: 'api-status online', 
          icon: 'ğŸŸ¢', 
          text: message || 'å®æ—¶æ•°æ®è¿æ¥' 
        },
        offline: { 
          class: 'api-status offline', 
          icon: 'ğŸ”´', 
          text: message || 'APIè¿æ¥å¼‚å¸¸' 
        },
        warning: { 
          class: 'api-status warning', 
          icon: 'ğŸŸ¡', 
          text: message || 'ç³»ç»Ÿå‡†å¤‡ä¸­' 
        }
      };
      
      const config = statusConfig[status] || statusConfig.offline;
      statusElement.className = config.class;
      statusElement.innerHTML = `${config.icon} ${config.text}`;
    }

    async function fetchWithRetry(url, options = {}, maxRetries = CONFIG.MAX_RETRIES) {
      for (let i = 0; i < maxRetries; i++) {
        try {
          const controller = new AbortController();
          const timeoutId = setTimeout(() => controller.abort(), 15000); // 15s timeout
          
          const response = await fetch(url, {
            ...options,
            signal: controller.signal,
            cache: 'default', // æ˜ç¡®è®¾ç½®ç¼“å­˜ç­–ç•¥é¿å…CORSé—®é¢˜
            mode: 'cors', // æ˜ç¡®è®¾ç½®CORSæ¨¡å¼
            headers: {
              'Accept': 'application/json',
              ...options.headers
            }
          });
          
          clearTimeout(timeoutId);
          
          if (!response.ok) {
            throw new Error(`HTTP ${response.status}: ${response.statusText}`);
          }
          
          const data = await response.json();
          globalState.errorCount = 0; // Reset error count on success
          return data;
          
        } catch (error) {
          console.warn(`APIè¯·æ±‚å¤±è´¥ (ç¬¬${i + 1}/${maxRetries}æ¬¡): ${error.message}`);
          globalState.errorCount++;
          
          if (i === maxRetries - 1) {
            throw error;
          }
          
          // Exponential backoff with jitter
          const delay = CONFIG.RETRY_DELAY_MS * Math.pow(2, i) + Math.random() * 1000;
          await new Promise(resolve => setTimeout(resolve, delay));
        }
      }
    }

    function getUrlParameter(name) {
      const urlParams = new URLSearchParams(window.location.search);
      return urlParams.get(name);
    }

    function updateUrl(asset) {
      const url = new URL(window.location);
      url.searchParams.set('asset', asset);
      window.history.pushState({}, '', url);
    }

    function initializeFromUrl() {
      const urlAsset = getUrlParameter('asset');
      if (urlAsset && assetConfigs[urlAsset.toUpperCase()]) {
        globalState.currentAsset = urlAsset.toUpperCase();
      }
    }

    function formatNumber(num, precision = 2) {
      if (num == null || isNaN(num)) return 'N/A';
      
      const absNum = Math.abs(num);
      if (absNum >= 1e9) return (num / 1e9).toFixed(1) + 'B';
      if (absNum >= 1e6) return (num / 1e6).toFixed(1) + 'M';
      if (absNum >= 1e3) return (num / 1e3).toFixed(1) + 'K';
      
      return num.toFixed(precision);
    }

    function formatCurrency(num, symbol = '$') {
      return symbol + formatNumber(num);
    }

    function formatPercentage(num) {
      if (num == null || isNaN(num)) return 'N/A';
      const sign = num >= 0 ? '+' : '';
      return sign + num.toFixed(2) + '%';
    }

    function formatDate(date) {
      return date.toLocaleDateString('zh-CN', { 
        year: 'numeric', 
        month: '2-digit', 
        day: '2-digit' 
      });
    }

    function getCacheKey(asset, type = 'price') {
      return `${asset}_${type}_${new Date().toDateString()}`;
    }

    function setCacheData(key, data, ttl = 300000) { // 5 minutes TTL
      globalState.dataCache.set(key, {
        data,
        timestamp: Date.now(),
        ttl
      });
    }

    function getCacheData(key) {
      const cached = globalState.dataCache.get(key);
      if (!cached) return null;
      
      if (Date.now() - cached.timestamp > cached.ttl) {
        globalState.dataCache.delete(key);
        return null;
      }
      
      return cached.data;
    }

    // ===========================
    // API DATA FETCHING FUNCTIONS
    // ===========================
    
    async function fetchFMPHistoricalData(symbol) {
      console.log(`ğŸ“Š è·å–FMPå†å²æ•°æ®: ${symbol}`);
      
      const cacheKey = getCacheKey(symbol, 'fmp');
      const cached = getCacheData(cacheKey);
      if (cached) {
        console.log(`ğŸ“‹ ä½¿ç”¨ç¼“å­˜æ•°æ®: ${symbol}`);
        return cached;
      }

      try {
        const url = `${CONFIG.FMP_BASE_URL}/historical-price-full/${symbol}?apikey=${CONFIG.FMP_API_KEY}`;
        
        const data = await fetchWithRetry(url);

        if (!data || !data.historical || !Array.isArray(data.historical)) {
          throw new Error('Invalid FMP API response format');
        }

        const processedData = data.historical
          .slice(0, CONFIG.CHART_DATA_POINTS)
          .map(item => ({
            date: new Date(item.date),
            price: parseFloat(item.close) || 0,
            indicatorPrice: parseFloat(item.close) || 0,
            volume: parseInt(item.volume) || 0,
            high: parseFloat(item.high) || 0,
            low: parseFloat(item.low) || 0,
            open: parseFloat(item.open) || 0
          }))
          .filter(item => item.price > 0)
          .sort((a, b) => a.date - b.date);

        if (processedData.length === 0) {
          throw new Error('No valid price data received');
        }

        setCacheData(cacheKey, processedData);
        updateApiStatus('online', 'å®æ—¶FMPæ•°æ®');
        
        console.log(`âœ… FMPæ•°æ®è·å–æˆåŠŸ: ${symbol}, ${processedData.length}æ¡è®°å½•`);
        return processedData;

      } catch (error) {
        console.error(`âŒ FMP APIé”™è¯¯ (${symbol}): ${error.message}`);
        throw error;
      }
    }

    async function fetchAlphaVantageData(symbol) {
      console.log(`ğŸ“ˆ è·å–Alpha Vantageæ•°æ®: ${symbol}`);
      
      const cacheKey = getCacheKey(symbol, 'alpha_vantage');
      const cached = getCacheData(cacheKey);
      if (cached) {
        console.log(`ğŸ“‹ ä½¿ç”¨Alpha Vantageç¼“å­˜æ•°æ®: ${symbol}`);
        return cached;
      }

      try {
        // å°è¯•ç›´æ¥Alpha Vantage API
        const url = `${CONFIG.ALPHA_VANTAGE_BASE_URL}?function=TIME_SERIES_DAILY&symbol=${symbol}&outputsize=compact&apikey=${CONFIG.ALPHA_VANTAGE_API_KEY}`;
        
        const data = await fetchWithRetry(url);

        if (data['Error Message']) {
          throw new Error(`Alpha Vantage Error: ${data['Error Message']}`);
        }

        if (data['Note']) {
          throw new Error('Alpha Vantage API call frequency limit reached');
        }

        const timeSeries = data['Time Series (Daily)'];
        if (!timeSeries) {
          throw new Error('Invalid Alpha Vantage response format');
        }

        const processedData = Object.entries(timeSeries)
          .slice(0, CONFIG.CHART_DATA_POINTS)
          .map(([date, values]) => ({
            date: new Date(date),
            price: parseFloat(values['4. close']) || 0,
            indicatorPrice: parseFloat(values['4. close']) || 0,
            volume: parseInt(values['5. volume']) || 0,
            high: parseFloat(values['2. high']) || 0,
            low: parseFloat(values['3. low']) || 0,
            open: parseFloat(values['1. open']) || 0
          }))
          .filter(item => item.price > 0)
          .sort((a, b) => a.date - b.date);

        if (processedData.length === 0) {
          throw new Error('No valid price data received from Alpha Vantage');
        }

        setCacheData(cacheKey, processedData);
        updateApiStatus('online', 'å®æ—¶Alpha Vantageæ•°æ®');
        
        console.log(`âœ… Alpha Vantageæ•°æ®è·å–æˆåŠŸ: ${symbol}, ${processedData.length}æ¡è®°å½•`);
        return processedData;

      } catch (error) {
        console.error(`âŒ Alpha Vantage APIé”™è¯¯ (${symbol}): ${error.message}`);
        throw error;
      }
    }

    async function fetchRapidAPIAlphaVantage(symbol) {
      console.log(`ğŸš€ è·å–RapidAPI Alpha Vantageæ•°æ®: ${symbol}`);
      
      const cacheKey = getCacheKey(symbol, 'rapidapi_alpha');
      const cached = getCacheData(cacheKey);
      if (cached) {
        console.log(`ğŸ“‹ ä½¿ç”¨RapidAPIç¼“å­˜æ•°æ®: ${symbol}`);
        return cached;
      }

      try {
        const url = `https://${CONFIG.RAPIDAPI_ALPHA_VANTAGE_HOST}/query?function=TIME_SERIES_DAILY&symbol=${symbol}&outputsize=compact&datatype=json`;
        
        const data = await fetchWithRetry(url, {
          headers: {
            'X-Rapidapi-Key': CONFIG.RAPIDAPI_KEY,
            'X-Rapidapi-Host': CONFIG.RAPIDAPI_ALPHA_VANTAGE_HOST
          }
        });

        if (data['Error Message']) {
          throw new Error(`RapidAPI Alpha Vantage Error: ${data['Error Message']}`);
        }

        const timeSeries = data['Time Series (Daily)'];
        if (!timeSeries) {
          throw new Error('Invalid RapidAPI Alpha Vantage response format');
        }

        const processedData = Object.entries(timeSeries)
          .slice(0, CONFIG.CHART_DATA_POINTS)
          .map(([date, values]) => ({
            date: new Date(date),
            price: parseFloat(values['4. close']) || 0,
            indicatorPrice: parseFloat(values['4. close']) || 0,
            volume: parseInt(values['5. volume']) || 0,
            high: parseFloat(values['2. high']) || 0,
            low: parseFloat(values['3. low']) || 0,
            open: parseFloat(values['1. open']) || 0
          }))
          .filter(item => item.price > 0)
          .sort((a, b) => a.date - b.date);

        if (processedData.length === 0) {
          throw new Error('No valid price data received from RapidAPI');
        }

        setCacheData(cacheKey, processedData);
        updateApiStatus('online', 'å®æ—¶RapidAPIæ•°æ®');
        
        console.log(`âœ… RapidAPI Alpha Vantageæ•°æ®è·å–æˆåŠŸ: ${symbol}, ${processedData.length}æ¡è®°å½•`);
        return processedData;

      } catch (error) {
        console.error(`âŒ RapidAPI Alpha Vantage APIé”™è¯¯ (${symbol}): ${error.message}`);
        throw error;
      }
    }

    async function fetchCoinGeckoHistoricalData(coinId) {
      console.log(`ğŸª™ è·å–CoinGeckoå†å²ä»·æ ¼æ•°æ®: ${coinId}`);
      
      const cacheKey = getCacheKey(coinId, 'coingecko_historical');
      const cached = getCacheData(cacheKey);
      if (cached) {
        console.log(`ğŸ“‹ ä½¿ç”¨CoinGeckoç¼“å­˜æ•°æ®: ${coinId}`);
        return cached;
      }

      try {
        // Get current price first
        const currentPriceUrl = `${CONFIG.COINGECKO_BASE_URL}/simple/price?ids=${coinId}&vs_currencies=usd&include_24hr_change=true`;
        const currentPriceData = await fetchWithRetry(currentPriceUrl);
        
        if (!currentPriceData[coinId]) {
          throw new Error('æ— æ³•è·å–å½“å‰ä»·æ ¼');
        }
        
        const currentPrice = currentPriceData[coinId].usd;
        const change24h = currentPriceData[coinId].usd_24h_change || 0;
        
        // Get historical data
        const historicalUrl = `${CONFIG.COINGECKO_BASE_URL}/coins/${coinId}/market_chart?vs_currency=usd&days=${CONFIG.CHART_DATA_POINTS}&interval=daily`;
        const historicalData = await fetchWithRetry(historicalUrl);
        
        if (!historicalData.prices || !Array.isArray(historicalData.prices)) {
          throw new Error('æ— æ•ˆçš„CoinGeckoå†å²æ•°æ®æ ¼å¼');
        }

        // Process historical data
        let processedData = historicalData.prices
          .map(([timestamp, price], index) => {
            const volume = historicalData.total_volumes && historicalData.total_volumes[index] 
              ? historicalData.total_volumes[index][1] : 0;
            
            return {
              date: new Date(timestamp),
              price: price,
              indicatorPrice: price,
              volume: volume,
              high: price * 1.02, // Approximate high
              low: price * 0.98,  // Approximate low
              open: price * 0.999 // Approximate open
            };
          })
          .filter(item => item.price > 0)
          .sort((a, b) => a.date - b.date);

        // Update the last entry with the most current price
        if (processedData.length > 0) {
          const lastEntry = processedData[processedData.length - 1];
          lastEntry.price = currentPrice;
          lastEntry.indicatorPrice = currentPrice;
          lastEntry.change24h = change24h;
        }

        if (processedData.length === 0) {
          throw new Error('æ²¡æœ‰æœ‰æ•ˆçš„ä»·æ ¼æ•°æ®');
        }

        setCacheData(cacheKey, processedData);
        updateApiStatus('online', 'å®æ—¶CoinGeckoæ•°æ®');
        
        console.log(`âœ… CoinGeckoå†å²æ•°æ®è·å–æˆåŠŸ: ${coinId}, ${processedData.length}æ¡è®°å½•, å½“å‰ä»·æ ¼: ${currentPrice}`);
        return processedData;

      } catch (error) {
        console.error(`âŒ CoinGeckoå†å²æ•°æ®APIé”™è¯¯ (${coinId}): ${error.message}`);
        throw error;
      }
    }

    async function fetchCoinGeckoData(coinId) {
      console.log(`ğŸª™ è·å–CoinGeckoå½“å‰ä»·æ ¼: ${coinId}`);
      
      const cacheKey = getCacheKey(coinId, 'coingecko_current');
      const cached = getCacheData(cacheKey);
      if (cached) {
        console.log(`ğŸ“‹ ä½¿ç”¨å½“å‰ä»·æ ¼ç¼“å­˜æ•°æ®: ${coinId}`);
        return cached;
      }

      try {
        const url = `${CONFIG.COINGECKO_BASE_URL}/simple/price?ids=${coinId}&vs_currencies=usd&include_24hr_change=true&include_24hr_vol=true`;
        
        const data = await fetchWithRetry(url);
        
        if (!data[coinId]) {
          throw new Error('æ— æ•ˆçš„CoinGecko APIå“åº”æ ¼å¼');
        }

        const coinData = data[coinId];
        const currentPrice = coinData.usd;
        const change24h = coinData.usd_24h_change || 0;
        const volume24h = coinData.usd_24h_vol || 0;

        // Create a simple current price data structure
        const processedData = {
          price: currentPrice,
          change24h: change24h,
          volume24h: volume24h,
          timestamp: new Date()
        };

        setCacheData(cacheKey, processedData, 60000); // 1 minute cache for current price
        updateApiStatus('online', 'å®æ—¶CoinGeckoæ•°æ®');
        
        console.log(`âœ… CoinGeckoå½“å‰ä»·æ ¼è·å–æˆåŠŸ: ${coinId}, ä»·æ ¼: ${currentPrice}`);
        return processedData;

      } catch (error) {
        console.error(`âŒ CoinGeckoå½“å‰ä»·æ ¼APIé”™è¯¯ (${coinId}): ${error.message}`);
        throw error;
      }
    }

    async function fetchTQQQData() {
      console.log('ğŸ“ˆ è·å–TQQQå’ŒQQQå¤åˆæ•°æ®');
      
      const cacheKey = getCacheKey('TQQQ_QQQ', 'composite');
      const cached = getCacheData(cacheKey);
      if (cached) {
        console.log('ğŸ“‹ ä½¿ç”¨TQQQç¼“å­˜æ•°æ®');
        return cached;
      }

      try {
        // å°è¯•å¤šä¸ªAPIæºè·å–TQQQå’ŒQQQæ•°æ®
        let tqqqData = [];
        let qqqData = [];

        // 1. é¦–å…ˆå°è¯•FMP API
        try {
          console.log('ğŸ”„ å°è¯•FMP APIè·å–TQQQå’ŒQQQæ•°æ®...');
          const [tqqqPromise, qqqPromise] = await Promise.allSettled([
            fetchFMPHistoricalData('TQQQ'),
            fetchFMPHistoricalData('QQQ')
          ]);

          if (tqqqPromise.status === 'fulfilled') {
            tqqqData = tqqqPromise.value;
            console.log('âœ… FMP TQQQæ•°æ®è·å–æˆåŠŸ');
          }
          
          if (qqqPromise.status === 'fulfilled') {
            qqqData = qqqPromise.value;
            console.log('âœ… FMP QQQæ•°æ®è·å–æˆåŠŸ');
          }
        } catch (fmpError) {
          console.warn('âŒ FMP APIè·å–å¤±è´¥:', fmpError.message);
        }

        // 2. å¦‚æœFMPå¤±è´¥ï¼Œå°è¯•Alpha Vantage API
        if (tqqqData.length === 0 || qqqData.length === 0) {
          console.log('ğŸ”„ FMPå¤±è´¥ï¼Œå°è¯•Alpha Vantage API...');
          
          try {
            if (tqqqData.length === 0) {
              tqqqData = await fetchAlphaVantageData('TQQQ');
              console.log('âœ… Alpha Vantage TQQQæ•°æ®è·å–æˆåŠŸ');
            }
          } catch (alphaError) {
            console.warn('âŒ Alpha Vantage TQQQè·å–å¤±è´¥:', alphaError.message);
          }

          try {
            if (qqqData.length === 0) {
              qqqData = await fetchAlphaVantageData('QQQ');
              console.log('âœ… Alpha Vantage QQQæ•°æ®è·å–æˆåŠŸ');
            }
          } catch (alphaError) {
            console.warn('âŒ Alpha Vantage QQQè·å–å¤±è´¥:', alphaError.message);
          }
        }

        // 3. å¦‚æœAlpha Vantageä¹Ÿå¤±è´¥ï¼Œå°è¯•RapidAPI
        if (tqqqData.length === 0 || qqqData.length === 0) {
          console.log('ğŸ”„ Alpha Vantageå¤±è´¥ï¼Œå°è¯•RapidAPI...');
          
          try {
            if (tqqqData.length === 0) {
              tqqqData = await fetchRapidAPIAlphaVantage('TQQQ');
              console.log('âœ… RapidAPI TQQQæ•°æ®è·å–æˆåŠŸ');
            }
          } catch (rapidError) {
            console.warn('âŒ RapidAPI TQQQè·å–å¤±è´¥:', rapidError.message);
          }

          try {
            if (qqqData.length === 0) {
              qqqData = await fetchRapidAPIAlphaVantage('QQQ');
              console.log('âœ… RapidAPI QQQæ•°æ®è·å–æˆåŠŸ');
            }
          } catch (rapidError) {
            console.warn('âŒ RapidAPI QQQè·å–å¤±è´¥:', rapidError.message);
          }
        }

        // 4. å¦‚æœæ‰€æœ‰APIéƒ½å¤±è´¥ï¼Œä½¿ç”¨é«˜è´¨é‡æ¨¡æ‹Ÿæ•°æ®
        if (tqqqData.length === 0) {
          console.warn('ğŸ­ æ‰€æœ‰TQQQ APIéƒ½å¤±è´¥ï¼Œä½¿ç”¨é«˜è´¨é‡æ¨¡æ‹Ÿæ•°æ®');
          tqqqData = generateHighQualityMockData(75, 'TQQQ');
        }

        if (qqqData.length === 0) {
          console.warn('ğŸ­ æ‰€æœ‰QQQ APIéƒ½å¤±è´¥ï¼Œä½¿ç”¨é«˜è´¨é‡æ¨¡æ‹Ÿæ•°æ®');
          qqqData = generateHighQualityMockData(400, 'QQQ');
        }

        // åˆå¹¶æ•°æ®ï¼Œä½¿ç”¨QQQä½œä¸ºTQQQäº¤æ˜“ä¿¡å·çš„æŒ‡æ ‡
        const mergedData = [];
        const qqqMap = new Map(qqqData.map(item => [item.date.getTime(), item]));

        tqqqData.forEach(tqqqItem => {
          const qqqItem = qqqMap.get(tqqqItem.date.getTime());
          
          mergedData.push({
            date: tqqqItem.date,
            price: tqqqItem.price, // TQQQ price for position
            indicatorPrice: qqqItem ? qqqItem.price : tqqqItem.price / 3, // QQQ price for signals
            secondaryPrice: qqqItem ? qqqItem.price : tqqqItem.price / 3, // QQQ price for display
            volume: tqqqItem.volume + (qqqItem ? qqqItem.volume : 0),
            high: tqqqItem.high,
            low: tqqqItem.low,
            open: tqqqItem.open
          });
        });

        if (mergedData.length === 0) {
          throw new Error('No valid merged data available');
        }

        setCacheData(cacheKey, mergedData);
        console.log(`âœ… TQQQå¤åˆæ•°æ®å¤„ç†å®Œæˆ: ${mergedData.length}æ¡è®°å½•`);
        
        return mergedData;

      } catch (error) {
        console.error(`âŒ TQQQæ•°æ®å¤„ç†é”™è¯¯: ${error.message}`);
        throw error;
      }
    }

    // ===========================
    // HIGH-QUALITY MOCK DATA GENERATION
    // ===========================
    
    function generateCryptoHistoricalData(currentPrice, symbol) {
      console.log(`ğŸ­ åŸºäºå½“å‰ä»·æ ¼ç”Ÿæˆ${symbol}å†å²æ•°æ®: ${currentPrice}`);
      
      const data = [];
      const today = new Date();
      const volatility = symbol.includes('BTC') ? 0.08 : 0.1;
      let price = currentPrice;
      
      // Generate backwards from current price
      for (let i = CONFIG.CHART_DATA_POINTS - 1; i >= 0; i--) {
        const date = new Date(today);
        date.setDate(date.getDate() - i);
        
        // Add some realistic price movement
        const change = (Math.random() - 0.5) * volatility * 2;
        price = price * (1 + change);
        price = Math.max(price, currentPrice * 0.3); // Don't go below 30% of current
        
        data.push({
          date: date,
          price: price,
          indicatorPrice: price,
          volume: Math.floor(Math.random() * 1000000) + 500000,
          high: price * (1 + Math.random() * 0.05),
          low: price * (1 - Math.random() * 0.05),
          open: price * (0.98 + Math.random() * 0.04)
        });
      }
      
      // Reverse to get chronological order
      return data.reverse();
    }
    
    function generateHighQualityMockData(basePrice, symbol) {
      console.log(`ğŸ­ ç”Ÿæˆé«˜è´¨é‡${symbol}æ¨¡æ‹Ÿæ•°æ®`);
      
      const data = [];
      const today = new Date();
      const volatility = symbol === 'BTC' ? 0.08 : symbol === 'ETH' ? 0.1 : 0.12;
      const trendStrength = 0.3;
      
      for (let i = CONFIG.CHART_DATA_POINTS - 1; i >= 0; i--) {
        const date = new Date(today);
        date.setDate(date.getDate() - i);
        
        // Generate realistic price movement with trends and volatility
        const timeProgress = i / CONFIG.CHART_DATA_POINTS;
        const trendComponent = Math.sin(timeProgress * Math.PI * 2) * trendStrength;
        const volatilityComponent = (Math.random() - 0.5) * volatility;
        const momentum = Math.sin(timeProgress * Math.PI * 4) * 0.1;
        
        const priceMultiplier = 1 + trendComponent + volatilityComponent + momentum;
        const price = Math.max(basePrice * priceMultiplier, basePrice * 0.3);
        
        data.push({
          date: date,
          price: price,
          indicatorPrice: price,
          volume: Math.floor(Math.random() * 1000000) + 500000,
          high: price * (1 + Math.random() * 0.05),
          low: price * (1 - Math.random() * 0.05),
          open: price * (0.98 + Math.random() * 0.04)
        });
      }
      
      console.log(`âœ… ${symbol}æ¨¡æ‹Ÿæ•°æ®ç”Ÿæˆå®Œæˆ: ${data.length}æ¡è®°å½•`);
      return data;
    }

    // ===========================
    // MAIN DATA LOADING FUNCTION
    // ===========================
    
    async function loadAssetData(asset) {
      console.log(`ğŸ”„ å¼€å§‹åŠ è½½${asset}æ•°æ®`);
      globalState.lastUpdateTime = new Date();
      globalState.isLoading = true;
      
      try {
        let data;
        const config = assetConfigs[asset];
        
        switch (asset) {
          case 'BTC':
            try {
              // ç›´æ¥ä½¿ç”¨CoinGecko APIè·å–BTCæ•°æ®
              data = await fetchCoinGeckoHistoricalData(config.coinGeckoId);
            } catch (error) {
              console.warn('CoinGeckoè·å–BTCæ•°æ®å¤±è´¥ï¼Œä½¿ç”¨å¤‡ç”¨æ•°æ®');
              data = generateHighQualityMockData(67000, 'BTC');
            }
            break;
            
          case 'ETH':
            try {
              // ç›´æ¥ä½¿ç”¨CoinGecko APIè·å–ETHæ•°æ®
              data = await fetchCoinGeckoHistoricalData(config.coinGeckoId);
            } catch (error) {
              console.warn('CoinGeckoè·å–ETHæ•°æ®å¤±è´¥ï¼Œä½¿ç”¨å¤‡ç”¨æ•°æ®');
              data = generateHighQualityMockData(3800, 'ETH');
            }
            break;
            
          case 'TQQQ':
            try {
              data = await fetchTQQQData();
            } catch (error) {
              console.warn('ä½¿ç”¨TQQQå¤‡ç”¨æ•°æ®');
              data = generateHighQualityMockData(75, 'TQQQ').map(item => ({
                ...item,
                secondaryPrice: item.price * 5.5 // Approximate QQQ price
              }));
            }
            break;
            
          default:
            data = generateHighQualityMockData(50000, asset);
        }

        console.log(`âœ… ${asset}æ•°æ®åŠ è½½å®Œæˆï¼Œå…±${data.length}æ¡è®°å½•`);
        return data;
        
      } catch (error) {
        console.error(`âŒ ${asset}æ•°æ®åŠ è½½å¤±è´¥:`, error);
        updateApiStatus('offline', 'APIè¿æ¥å¤±è´¥');
        
        // Emergency fallback data
        const fallbackPrices = { BTC: 67000, ETH: 3800, TQQQ: 75 };
        return generateHighQualityMockData(fallbackPrices[asset] || 50000, asset);
        
      } finally {
        globalState.isLoading = false;
      }
    }

    // ===========================
    // TECHNICAL ANALYSIS FUNCTIONS
    // ===========================
    
    function calculateTechnicalIndicators(data) {
      console.log('ğŸ“Š è®¡ç®—æŠ€æœ¯æŒ‡æ ‡');
      
      // Calculate 20-day Moving Average
      const dataWithMA = data.map((row, index, arr) => {
        let MA20 = null;
        let MA50 = null;
        
        if (index >= CONFIG.MA_PERIOD - 1) {
          const prices = arr.slice(index - CONFIG.MA_PERIOD + 1, index + 1)
                           .map(r => r.indicatorPrice);
          if (prices.length === CONFIG.MA_PERIOD && prices.every(p => typeof p === 'number' && !isNaN(p))) {
            MA20 = prices.reduce((sum, p) => sum + p, 0) / CONFIG.MA_PERIOD;
          }
        }
        
        if (index >= 49) { // 50-day MA
          const prices50 = arr.slice(index - 49, index + 1).map(r => r.indicatorPrice);
          if (prices50.length === 50 && prices50.every(p => typeof p === 'number' && !isNaN(p))) {
            MA50 = prices50.reduce((sum, p) => sum + p, 0) / 50;
          }
        }
        
        return { ...row, MA20, MA50 };
      });
      
      // Calculate trend direction and additional indicators
      const dataWithIndicators = dataWithMA.map((row, index, arr) => {
        let MAtrend = 'æœªçŸ¥';
        let momentum = 0;
        let volatility = 0;
        
        if (row.MA20 != null && index > 0) {
          const prevMA20 = arr[index - 1].MA20;
          if (prevMA20 != null) {
            MAtrend = row.MA20 > prevMA20 ? 'ä¸Šå‡' : 'ä¸‹é™';
            momentum = ((row.MA20 - prevMA20) / prevMA20) * 100;
          }
        }
        
        // Calculate volatility (standard deviation of last 10 days)
        if (index >= 9) {
          const recentPrices = arr.slice(index - 9, index + 1).map(r => r.indicatorPrice);
          const mean = recentPrices.reduce((sum, p) => sum + p, 0) / recentPrices.length;
          const variance = recentPrices.reduce((sum, p) => sum + Math.pow(p - mean, 2), 0) / recentPrices.length;
          volatility = Math.sqrt(variance) / mean * 100;
        }
        
        return { ...row, MAtrend, momentum, volatility };
      });
      
      console.log('âœ… æŠ€æœ¯æŒ‡æ ‡è®¡ç®—å®Œæˆ');
      return dataWithIndicators;
    }

    function generateTradingSignals(data) {
      console.log('ğŸ¯ ç”Ÿæˆäº¤æ˜“ä¿¡å·');
      
      const dataWithSignals = data.reduce((accumulator, currentRow, index) => {
        let signal = '';
        let signalStrength = 0; // 0-100, signal confidence
        let signalReason = '';
        const prevPosition = index > 0 ? accumulator[index - 1].POSITION : 'ç©ºä»“';
        let currentPosition = prevPosition;

        if (index >= CONFIG.MA_PERIOD - 1 && currentRow.MA20 != null && currentRow.MAtrend !== 'æœªçŸ¥') {
          const currentPrice = parseFloat(currentRow.indicatorPrice);
          const currentMA = parseFloat(currentRow.MA20);
          const currentTrend = currentRow.MAtrend;
          const momentum = currentRow.momentum || 0;
          const volatility = currentRow.volatility || 0;
          
          if (currentPrice && currentMA && currentTrend) {
            const buyThreshold = currentMA * CONFIG.BUY_THRESHOLD;
            const sellThreshold = currentMA * CONFIG.SELL_THRESHOLD;
            const priceDistanceFromMA = ((currentPrice - currentMA) / currentMA) * 100;
            
            // Enhanced buy conditions
            const condition1_buy = prevPosition === 'ç©ºä»“';
            const condition2_buy = currentTrend === 'ä¸Šå‡';
            const condition3_buy = currentPrice > buyThreshold;
            const condition4_buy = momentum > 0.1; // Positive momentum
            const condition5_buy = volatility < 15; // Low volatility for stable entry
            
            if (condition1_buy && condition2_buy && condition3_buy) {
              signal = 'ä¹°å…¥';
              currentPosition = 'æŒæœ‰';
              signalStrength = 60 + (condition4_buy ? 20 : 0) + (condition5_buy ? 20 : 0);
              signalReason = `ä»·æ ¼çªç ´20æ—¥å‡çº¿${priceDistanceFromMA.toFixed(1)}%ï¼Œè¶‹åŠ¿${currentTrend}`;
            }
            
            // Enhanced sell conditions
            const condition1_sell = prevPosition === 'æŒæœ‰';
            const condition2_sell = currentTrend === 'ä¸‹é™';
            const condition3_sell = currentPrice < sellThreshold;
            const condition4_sell = momentum < -0.1; // Negative momentum
            
            if (condition1_sell && condition2_sell && condition3_sell) {
              signal = 'å–å‡º';
              currentPosition = 'ç©ºä»“';
              signalStrength = 60 + (condition4_sell ? 20 : 0) + (volatility > 20 ? 20 : 0);
              signalReason = `ä»·æ ¼è·Œç ´20æ—¥å‡çº¿${Math.abs(priceDistanceFromMA).toFixed(1)}%ï¼Œè¶‹åŠ¿${currentTrend}`;
            }
          }
        }
        
        accumulator.push({ 
          ...currentRow, 
          Signal: signal, 
          POSITION: currentPosition,
          signalStrength,
          signalReason
        });
        return accumulator;
      }, []);
      
      console.log('âœ… äº¤æ˜“ä¿¡å·ç”Ÿæˆå®Œæˆ');
      return dataWithSignals;
    }
